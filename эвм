Отличный список вопросов по архитектуре вычислительных систем и низкоуровневой организации ЭВМ. Вот развернутые ответы на каждый пункт, которые можно использовать для подготовки к контрольной работе.

---

### 1. Принцип программного управления
**Принцип программного управления** — фундаментальный принцип архитектуры фон Неймана, согласно которому:
*   **Программа состоит из последовательности команд**, хранящихся в памяти, как и данные.
*   **Команды выполняются процессором автоматически и последовательно** (если не указано иное, например, переходом), в порядке, определяемом счетчиком команд (Program Counter, PC).
*   **Исполнительный цикл процессора (машинный цикл)** включает:
    1.  **Выборка (Fetch)** команды из памяти по адресу из PC.
    2.  **Декодирование (Decode)** команды.
    3.  **Исполнение (Execute)** команды.
    4.  **Инкремент PC** для перехода к следующей команде (или изменение PC при командах перехода).

---

### 2. Обобщенная структура ЭВМ
Обобщенная структура (архитектура фон Неймана) включает:
1.  **Арифметико-логическое устройство (АЛУ)** — выполняет арифметические и логические операции.
2.  **Устройство управления (УУ)** — управляет работой всех устройств, декодирует и выполняет команды.
3.  **Запоминающее устройство (память)** — хранит программы и данные. Иерархически организована (регистры, кэш, ОЗУ, ПЗУ, внешняя память).
4.  **Устройства ввода** (клавиатура, мышь) — для ввода информации.
5.  **Устройства вывода** (монитор, принтер) — для отображения результатов.
6.  **Системная шина** — связывает все компоненты, состоит из:
    *   **Шина данных** — передает данные.
    *   **Шина адреса** — передает адреса ячеек памяти/устройств.
    *   **Шина управления** — передает управляющие сигналы (чтение, запись, прерывание).

---

### 3. Принципы построения вычислительных систем
1.  **Принцип программного управления**.
2.  **Принцип однородности памяти**: программы и данные хранятся в одной памяти, доступ к ним происходит одинаково.
3.  **Принцип адресуемости памяти**: память состоит из пронумерованных ячеек, доступных по адресу.
4.  **Принцип иерархии памяти**: использование разных типов памяти (быстрая/дорогая и медленная/дешевая) для оптимизации скорости и стоимости.
5.  **Принцип двоичного кодирования**: вся информация (команды, данные, адреса) кодируется двоичными цифрами.
6.  **Принцип параллелизма**: одновременное выполнение нескольких операций для повышения производительности (конвейер, многоядерность).
7.  **Принцип модульности**: система строится из стандартных, функционально законченных модулей.
8.  **Принцип магистральности**: взаимодействие устройств через общую шину (системную магистраль).

---

### 4. Функциональная и структурная организация вычислительных систем
*   **Функциональная организация** — описывает систему с точки зрения **функций** (что делает): ввод, хранение, обработка, вывод, управление. Это "черный ящик", выполняющий алгоритм.
*   **Структурная организация** — описывает **физическую или логическую структуру** системы (из каких элементов состоит и как они связаны): процессоры, память, шины, контроллеры. Это "внутреннее устройство" системы.

**Пример**: С точки зрения функциональной организации ЭВМ — устройство для решения задач. С точки зрения структурной — это конкретная платформа (x86, ARM) с определенным набором микросхем и шин.

---

### 5. Принципы фон Неймана
Основополагающие принципы, предложенные Джоном фон Нейманом в 1945 году:
1.  **Принцип двоичного кодирования**: вся информация представляется в двоичной форме.
2.  **Принцип программного управления**: программа состоит из последовательности команд, выполняемых автоматически.
3.  **Принцип однородности памяти**: и команды, и данные хранятся в одной оперативной памяти и идентичны по форме представления.
4.  **Принцип адресуемости памяти**: память линейно адресуема, состоит из ячеек фиксированного размера, каждая имеет уникальный адрес.
5.  **Принцип последовательного выполнения команд**: команды выполняются в порядке их расположения в памяти, если команда перехода не изменяет этот порядок.
6.  **Жесткая логика управления**: УУ построено на схемной (аппаратной) логике, а не на программируемой (что отличает от гарвардской архитектуры, где управление также может быть "зашито").

---

### 6. Непосредственная адресация
**Адрес = само значение операнда.**
*   Операнд содержится непосредственно в поле команды.
*   **Плюсы**: высокая скорость (не нужен доступ к памяти за данными).
*   **Минусы**: ограниченный размер операнда (шириной поля команды).
*   **Пример команды**: `MOV AX, 15h` — загрузить в регистр AX число 15h.

---

### 7. Прямая адресация
**Адрес = значение поля адреса в команде.**
*   Поле команды содержит **абсолютный адрес** ячейки памяти, где хранится операнд.
*   **Плюсы**: простой способ указать на конкретную ячейку.
*   **Минусы**: сложность перелокации программы, так как адреса "зашиты" в код.
*   **Пример команды**: `MOV AX, [1050h]` — загрузить в AX содержимое ячейки с адресом 1050h.

---

### 8. Косвенная адресация
**Адрес = содержимое специального регистра или ячейки памяти, указанной в команде.**
*   Поле команды указывает **не на операнд, а на адрес операнда**.
*   **Плюсы**: гибкость (один и тот же код может работать с разными ячейками памяти, изменяя лишь содержимое регистра-указателя).
*   **Минусы**: требуется дополнительный цикл обращения к памяти для получения адреса.
*   **Пример команды**: `MOV AX, [BX]` — загрузить в AX содержимое ячейки, адрес которой хранится в регистре BX.

---

### 9. Стековая адресация
**Адрес = содержимое указателя стека (SP/ESP/RSP).**
*   Операнды располагаются в специальной области памяти — **стеке**, доступ к которой осуществляется по принципу LIFO (Last In, First Out). Указатель стека всегда указывает на вершину.
*   Команды работы со стеком (`PUSH`, `POP`) неявно используют SP.
*   **Плюсы**: удобство для организации вызовов подпрограмм, передачи параметров, временного хранения данных.
*   **Минусы**: произвольный доступ к элементам стека затруднен.
*   **Пример команды**: `PUSH AX` — положить значение регистра AX на вершину стека.

---

### 10. Неявная (подразумеваемая) адресация
**Адрес операнда или место его хранения заранее определено кодом операции.**
*   Команда не содержит явных ссылок на операнды.
*   **Плюсы**: компактность команды.
*   **Минусы**: отсутствие гибкости.
*   **Примеры команд**:
    *   `CLC` — сброс флага переноса CF (работает с конкретным флагом).
    *   Команды работы со строковыми данными в x86 (`MOVSB`) неявно используют регистры SI (источник) и DI (приемник).

---

### 11. Относительная (базовая) адресация
**Эффективный адрес = содержимое базового регистра + смещение (offset) из команды.**
*   **Базовый регистр** часто используется для указания на начало сегмента данных или структуры.
*   **Смещение** — константа в команде.
*   **Плюсы**: удобство для организации модульных программ и работы с локальными переменными в стеке (базовый регистр — `EBP`).
*   **Пример**: `MOV AX, [BP+8]` — взять данные по адресу, равному содержимому BP плюс 8 байт.

---

### 12. Индексная адресация
**Эффективный адрес = содержимое индексного регистра + база (обычно адрес начала массива).**
*   **Индексный регистр** (SI, DI, в x86-64 — RSI, RDI, и др.) используется для перебора элементов массива или строки.
*   База может быть явной константой или содержаться в другом регистре.
*   **Плюсы**: идеально подходит для работы с массивами.
*   **Пример**: `MOV AL, [Array + SI]` — взять байт из массива `Array` с индексом SI.

---

### 13. Инкрементная адресация
**Разновидность косвенной или индексной адресации, при которой после использования адреса он автоматически увеличивается (инкрементируется).**
*   Используется для последовательного чтения/записи данных (например, в строках или массивах).
*   **Пример**: В архитектуре x86 команда `LODSB` загружает байт из памяти по адресу `[SI]` в `AL`, а затем увеличивает SI на 1.

---

### 14. Декрементная адресация
**Разновидность косвенной или индексной адресации, при которой перед использованием адреса он автоматически уменьшается (декрементируется).**
*   Часто используется при работе со стеком в архитектурах, где стек "растет" в сторону уменьшения адресов.
*   **Пример**: В архитектуре ARM можно использовать предекремент: `LDR R0, [R1, #-4]!` — сначала уменьшить R1 на 4, затем загрузить данные по новому адресу в R0.

---

### 15. Индексная адресация с шагом
**Эффективный адрес = база + индекс * масштабный множитель (шаг).**
*   **Шаг (scale)** — обычно равен 1, 2, 4 или 8 байтам. Позволяет легко адресовать элементы массивов разного размера (байты, слова, двойные слова и т.д.).
*   **Плюсы**: эффективная работа с массивами структур или разномасштабными данными без ручного пересчета индекса.
*   **Пример (x86)**: `MOV EAX, [EBX + ESI*4]` — загрузить в EAX элемент массива 32-битных целых чисел. ESI — индекс элемента, 4 — размер каждого элемента.

---

### 16. Базово-индексная адресация
**Эффективный адрес = база + индекс (+ смещение).**
*   Сочетает **базовый регистр** (указывает на начало структуры, например, массива структур) и **индексный регистр** (указывает на конкретную структуру внутри массива).
*   **Плюсы**: мощный метод для доступа к элементам сложных структур данных (например, двумерных массивов).
*   **Пример (x86)**: `MOV AX, [BX + SI + 10]`. BX — база массива структур, SI — смещение внутри одной структуры, 10 — смещение до конкретного поля.

---

### 17. Классификация компьютерной памяти
1.  **По принципу действия**:
    *   **Полупроводниковая** (SRAM, DRAM, Flash).
    *   **Магнитная** (жесткие диски, ленты).
    *   **Оптическая** (CD, DVD, Blu-ray).
    *   **Использующие новые принципы** (оптическая, фазопереходная, резистивная).
2.  **По энергозависимости**:
    *   **Энергозависимая (volatile)** — теряет данные при отключении питания (ОЗУ: DRAM, SRAM).
    *   **Энергонезависимая (non-volatile)** — сохраняет данные без питания (ПЗУ, Flash, HDD).
3.  **По назначению**:
    *   **Оперативная (ОЗУ/RAM)** — для временного хранения выполняемых программ и данных.
    *   **Постоянная (ПЗУ/ROM)** — для хранения неизменяемых данных (BIOS/UEFI).
    *   **Внешняя (накопители)** — для долговременного хранения больших объемов данных (HDD, SSD).
    *   **Кэш-память** — сверхбыстрая буферная память между процессором и ОЗУ.
4.  **По способу доступа**:
    *   **Память с произвольным доступом (RAM)** — время доступа не зависит от места расположения.
    *   **Память с последовательным доступом** — время доступа зависит от расположения (ленточные накопители).
    *   **Память с прямым доступом** — произвольный доступ, но с механическим поиском (HDD).

---

### 18. Методы доступа к памяти
1.  **С произвольным доступом (Random Access)**: доступ к любой ячейке за постоянное время. **Пример**: ОЗУ (DRAM, SRAM).
2.  **С последовательным доступом (Sequential Access)**: данные читаются/пишутся в строгом порядке. Время доступа зависит от текущего положения. **Пример**: магнитные ленты.
3.  **С прямым доступом (Direct Access)**: комбинация произвольного и последовательного. Есть механическая часть (позиционирование головки/диска), после чего доступ к секторам в найденной области быстрый. **Пример**: жесткие диски (HDD).
4.  **Ассоциативный доступ (Associative Access)**: память ищет данные не по адресу, а по содержимому (тегу). **Пример**: кэш-память (TLB, кэш данных).

---

### 19. Устройство ячейки динамической памяти
*   **Одна ячейка DRAM** состоит из:
    1.  **Конденсатора** — хранит заряд (есть заряд = логическая 1, нет заряда = 0).
    2.  **Транзистора** — играет роль ключа, который подключает конденсатор к разрядной/зарядной шине (bitline) при подаче сигнала на **шину слова (wordline)**.
*   **Ключевая проблема**: конденсатор постепенно теряет заряд (утечка). Требуется **периодическая регенерация (refresh)** для восстановления данных.

---

### 20. Структура динамической памяти
DRAM организована в виде **двумерной матрицы** ячеек (строки x столбцы).
*   **Строка (Row)**: все ячейки, подключенные к одной шине слова.
*   **Столбец (Column)**: все ячейки, подключенные к одной разрядной шине (bitline).
*   Для доступа к ячейке:
    1.  **Активация строки (RAS)**: подается сигнал на конкретную шину слова. Транзисторы всей строки открываются, и заряды с конденсаторов считываются на соответствующие bitline.
    2.  **Выбор столбца (CAS)**: мультиплексор выбирает нужную bitline из активированной строки и подключает ее к выходному усилителю/буферу.

---

### 21. Принцип работы динамической оперативной памяти: чтение
1.  **Активация строки (RAS)**: Подается адрес строки. Открываются все транзисторы выбранной строки. Крошечные заряды с конденсаторов передаются на линии bitline, вызывая небольшое изменение напряжения.
2.  **Усиление сигнала**: Чувствительный усилитель-восстановитель (sense amplifier) на каждой линии bitline усиливает это слабое изменение, определяя логический уровень (0 или 1). **Важно**: при этом конденсатор почти полностью разряжается (разрушающее чтение).
3.  **Выбор столбца (CAS)**: Подается адрес столбца. Мультиплексор выбирает один из усиленных сигналов от нужной bitline и подает его на выходной буфер памяти (на шину данных).
4.  **Регенерация строки**: Усилитель-восстановитель **немедленно** перезаписывает (регенерирует) считанное значение обратно в конденсаторы активированной строки.

---

### 22. Принцип работы динамической оперативной памяти: запись
1.  **Активация строки (RAS)**: Аналогично чтению.
2.  **Выбор столбца и подача данных (CAS)**: Подается адрес столбца и новые данные на шину данных.
3.  **Изменение заряда**: Сигнал записи заставляет усилитель-восстановитель на выбранной линии bitline установить такое напряжение, которое либо зарядит конденсатор выбранной ячейки (запись 1), либо разрядит его (запись 0).
4.  **Деактивация строки**: Шина слова отключается, транзисторы закрываются, изолируя обновленный заряд в конденсаторе.

---

### 23. Способы регенерации динамической памяти
Поскольку заряд конденсаторов утекает, все строки памяти необходимо периодически (каждые 64 мс) **регенерировать**.
1.  **RAS-Only Refresh**: Контроллер памяти циклически перебирает адреса строк и подает на них только сигнал RAS (без CAS). Это активирует строку, усилители считывают и немедленно перезаписывают данные обратно. Эффективно, но на время цикла регенерации память недоступна.
2.  **CAS Before RAS Refresh (CBR)**: Специальный режим, когда сигнал CAS подается раньше RAS. Это указывает памяти на внутреннюю регенерацию следующей строки по внутреннему счетчику. Позволяет контроллеру планировать регенерацию в периоды простоя шины.
3.  **Саморегенерация (Self Refresh)**: Режим энергосбережения. Внутренний генератор в микросхеме DRAM самостоятельно инициирует циклы регенерации. Память отключается от внешнего контроллера и сохраняет данные при минимальном энергопотреблении (используется в ноутбуках, планшетах).

---

### 24. Банки и каналы памяти
*   **Банк памяти (Memory Bank)**: Независимый массив ячеек внутри модуля памяти (чипа DRAM), который может выполнять операции (активацию строки, чтение/запись) параллельно с другими банками. **Позволяет скрывать задержки** (пока в одном банке идет регенерация, другой может обрабатывать данные).
*   **Канал памяти (Memory Channel)**: Независимый путь (совокупность линий данных, адреса и управления) между контроллером памяти (в CPU) и набором модулей DIMM. **Удваивает/утраивает пропускную способность**. Примеры: двухканальный (Dual-Channel), четырехканальный (Quad-Channel) режимы.

---

### 25. Тайминги памяти
Задержки (латентность) при операциях с DRAM, измеряются в тактах. Основные тайминги (например, CL16-18-18-36):
*   **CL (CAS Latency)**: Задержка между отправкой адреса столбца (CAS) и появлением данных на выходе. Самый важный тайминг.
*   **tRCD (RAS to CAS Delay)**: Задержка между активацией строки (RAS) и возможностью отправки адреса столбца (CAS). Минимальное время на зарядку bitline.
*   **tRP (RAS Precharge Time)**: Время, необходимое для закрытия (деактивации) текущей строки и подготовки к активации новой.
*   **tRAS (Active to Precharge Delay)**: Минимальное время, в течение которого строка должна оставаться активной между командой активации и командой закрытия.
*   **Командно-адресная задержка (CR, tCWL и др.)** — дополнительные параметры.

---

### 26. Типы динамической памяти
*   **SDRAM (Synchronous DRAM)**: Синхронная память, работающая от общего тактового сигнала с процессором.
    *   **SDR SDRAM** (Single Data Rate): передает данные один раз за такт.
    *   **DDR SDRAM** (Double Data Rate): передает данные 2 раза за такт (по фронту и срезу).
        *   **DDR, DDR2, DDR3, DDR4, DDR5** — поколения с увеличением скорости, снижением напряжения и улучшением архитектуры.
*   **LPDDR** (Low Power DDR): версия для мобильных устройств с пониженным энергопотреблением.
*   **GDDR** (Graphics DDR): высокоскоростная память с широкой шиной, оптимизированная для видеокарт (GDDR6, GDDR6X).
*   **HBM** (High Bandwidth Memory): память с вертикальной 3D-структурой и сверхширокой шиной (1024-2048 бит на стек), размещаемая на одном кристалле с GPU/CPU (очень высокая пропускная способность).

---

### 27. Устройство триггера и устройство инвертора
*   **Инвертор (NOT gate)**: Простейший логический элемент. Имеет один вход и один выход. Выдает на выходе сигнал, противоположный входному (1→0, 0→1). Строится на двух транзисторах (CMOS-технология: p-MOS и n-MOS).
*   **Триггер (Flip-Flop)**: Элементарная ячейка **статической памяти (SRAM)**, способная хранить 1 бит. Это **последовательностная схема** с обратной связью. Самый распространенный тип для памяти — **RS-триггер**, построенный на двух перекрестно-связанных инверторах (образующих петлю с положительной обратной связью) и двух-четырех транзисторах доступа. Обладает двумя устойчивыми состояниями (0 или 1), которые сохраняются до подачи сигнала записи или отключения питания.

---

### 28. Структура стандартной 6T-ячейки SRAM
*   **6 транзисторов (6T)**:
    1.  **2 транзистора (n-MOS) доступа (Access Transistors)**: Соединяют ячейку с линиями битов (Bitline, `BL` и `~BL`). Управляются общей линией слова (Wordline, `WL`).
    2.  **4 транзистора, образующих два инвертора (Storage Latch)**:
        *   2 транзистора (один p-MOS, один n-MOS) формируют первый инвертор.
        *   2 транзистора (один p-MOS, один n-MOS) формируют второй инвертор.
*   **Выходы инверторов соединены крест-накрест**: Вход первого подключен к выходу второго и наоборот. Это создает устойчивую петлю обратной связи, хранящую один бит.
*   **Линии битов (`BL` и `~BL`)** — комплементарные (дополняющие друг друга). Для записи подаются разные напряжения, для чтения — отслеживается разность потенциалов.

---

### 29. Операция чтения из 6T-ячейки SRAM
1.  **Подготовка линий**: Линии `BL` и `~BL` предзаряжаются до высокого уровня (Vdd).
2.  **Активация строки**: На линию слова (`WL`) подается высокий сигнал. Оба транзистора доступа открываются, подключая внутренние узлы ячейки к линиям битов.
3.  **Разрядка одной линии**: В зависимости от хранимого значения, один из внутренних узлов имеет 0, другой — 1. Через открытые транзисторы начинается ток утечки, который **слегка разряжает** одну из линий битов (BL или ~BL). Например, если хранится 0, узел с 0 подключен к BL и начнет стягивать его напряжение вниз.
4.  **Усиление разницы**: Чувствительный усилитель (sense amplifier), подключенный к BL и ~BL, обнаруживает небольшую разность напряжений между ними и резко усиливает ее, определяя, какая линия "просела". На выходе усилителя формируется четкий сигнал (0 или 1).
5.  **Деактивация строки**: Сигнал WL снимается, транзисторы доступа закрываются, изолируя ячейку. **Важно**: чтение в SRAM — неразрушающее**, состояние ячейки не меняется.

---

### 30. Операция записи в 6T-ячейку SRAM
1.  **Установка линий**: На линии `BL` и `~BL` устанавливаются **противоположные** значения: `BL` = значение для записи, `~BL` = инверсное значение. Например, для записи 1: `BL` = 1 (Vdd), `~BL` = 0 (GND).
2.  **Активация строки**: На линию слова (`WL`) подается высокий сигнал. Транзисторы доступа открываются.
3.  **Перезапись состояния**: Сильные сигналы с линий битов **"пересиливают"** слабые транзисторы инверторов в ячейке. Если ячейка хранила 0, а мы подаем на BL=1, то ток с BL через открытый транзистор доступа начинает заряжать внутренний узел, который был 0, что в итоге переключает состояние двух инверторов.
4.  **Стабилизация**: Как только состояние ячейки изменилось, оно тут же стабилизируется петлей обратной связи.
5.  **Деактивация строки**: Сигнал WL снимается. Новое значение надежно сохранено.

---

### 31. Принцип магнитной записи
Основан на явлении **остаточной намагниченности** ферромагнитных материалов.
*   **Запись**: Записывающая головка создает локальное магнитное поле, направление которого меняется в зависимости от записываемого бита (0 или 1). Это поле намагничивает крошечную область (домен) магнитного слоя диска в определенном направлении (север-юг или юг-север).
*   **Хранение**: После снятия внешнего поля домен сохраняет намагниченность (остаточную индукцию).
*   **Чтение**: При движении намагниченной области под считывающей головкой (в современных дисках — головкой GMR или TMR) изменение магнитного потока индуцирует в ней электрический сигнал (или меняет ее сопротивление), который затем декодируется в последовательность битов.

---

### 32. Конструкция жесткого диска
1.  **Корпус (гермоблок)** — защищает от пыли.
2.  **Шпиндель** — вращает пакет магнитных дисков (пластин).
3.  **Магнитные диски (пластины)** — алюминиевые или стеклянные диски, покрытые ферромагнитным слоем.
4.  **Головки чтения/записи** — расположены на конце коромысла позиционера для каждой поверхности диска. Считывают и записывают данные.
5.  **Привод позиционера (актуатор)** — перемещает коромысло с головками по радиусу диска для доступа к нужным дорожкам.
6.  **Предусилитель** — усиливает слабый сигнал от головок и управляет током записи.
7.  **Плата управления (контроллер)** — электронная плата с процессором, памятью и интерфейсной логикой (SATA/SAS).

---

### 33. Логическая структура жёсткого диска
*   **Дорожка (Track)** — концентрическая окружность на одной стороне пластины.
*   **Цилиндр (Cylinder)** — совокупность дорожек, расположенных друг над другом на разных пластинах (доступных без перемещения головок).
*   **Сектор (Sector)** — минимальная адресуемая единица информации на диске (традиционно 512 байт, современные — 4096 байт, Advanced Format).
*   **Кластер (Cluster/Block)** — минимальная единица, выделяемая файловой системой для хранения файла. Состоит из одного или нескольких секторов.

**Адресация**:
*   **CHS (Cylinder-Head-Sector)**: Устаревший физический метод.
*   **LBA (Logical Block Addressing)**: Современный метод. Весь диск представлен как линейный массив логических блоков (секторов), пронумерованных от 0 до N-1.

---

### 34. Устройство flash-памяти
*   **Основной элемент** — транзистор с плавающим затвором (Floating Gate Transistor).
*   **Плавающий затвор** — изолированный слой, способный удерживать электрический заряд (электроны) в течение многих лет.
*   **Принцип хранения**: Наличие или отсутствие заряда на плавающем затворе изменяет пороговое напряжение транзистора. При подаче напряжения на управляющий затвор транзистор либо откроется (состояние "1"), либо останется закрытым (состояние "0").
*   **Операции**:
    *   **Стирание (Erase)**: Применяется высокое напряжение, электроны туннелируют с плавающего затвора (через тонкий слой оксида). Приводит все ячейки в блоке в состояние "1".
    *   **Запись (Program)**: Изменение состояния ячейки с "1" на "0". Применяется напряжение, загоняющее электроны на плавающий затвор. **Запись возможна только в предварительно стертые ячейки**.
    *   **Чтение (Read)**: Подается промежуточное напряжение. Проверяется, открывается ли транзистор.

---

### 35. Флэш-память NOR
*   **Структура**: Ячейки памяти подключены **параллельно** к битовым линиям (как в матрице логических элементов ИЛИ-НЕ, отсюда название).
*   **Характеристики**:
    *   **Произвольный доступ (Random Access)**: Возможность чтения любой ячейки по адресу за постоянное время.
    *   **Медленная запись и стирание**.
    *   **Низкая плотность упаковки** (большой размер ячейки).
    *   **Высокая надежность**.
*   **Применение**: Хранение кода (BIOS/UEFI, прошивки микроконтроллеров), где требуется быстрое произвольное чтение.

---

### 36. Флэш-память NAND
*   **Структура**: Ячейки соединены **последовательно** (как в NAND-гейте) в цепочки (строки, 16-64 ячейки). Цепочки объединены в страницы и блоки.
*   **Характеристики**:
    *   **Последовательно-страничный доступ**: Чтение и запись происходит целыми страницами (например, 4-16 КБ). Произвольный доступ медленный.
    *   **Быстрая запись и стирание** (на уровне блоков).
    *   **Высокая плотность упаковки** (маленький размер ячейки).
    *   **Более низкая надежность, чем у NOR** (требуется коррекция ошибок ECC).
*   **Применение**: Массовое хранение данных (SSD, флешки, карты памяти).

---

### 37. Устройство SSD
*   **Контроллер** — "мозг" SSD. Управляет памятью, кэшем, интерфейсом, выполняет garbage collection, wear leveling, шифрование.
*   **NAND флеш-память** — массив чипов, где хранятся данные. Организована в страницы и блоки.
*   **Кэш-память (DRAM, реже SLC)** — буфер для метаданных (таблицы трансляции адресов FTL) и/или пользовательских данных.
*   **Интерфейсный разъем** (SATA, PCIe/NVMe) — для подключения к системе.
*   **Функции контроллера**:
    *   **FTL (Flash Translation Layer)** — трансляция логических адресов (LBA) в физические адреса NAND, скрывающая особенности работы с флеш-памятью (стирание блоками).
    *   **Wear Leveling** — равномерное распределение циклов записи/стирания по всем ячейкам для продления срока службы.
    *   **Garbage Collection** — сбор "мусора": освобождение блоков, содержащих неактуальные данные.
    *   **Error Correction (ECC)** — исправление ошибок чтения.

---

### 38. Понятие архитектуры ВС и классификация Флинна
*   **Архитектура вычислительной системы (ВС)** — это концептуальная структура и функциональное поведение системы с точки зрения программиста, определяющая организацию потоков данных и команд.
*   **Классификация Флинна (Flynn's taxonomy, 1966)** — классифицирует архитектуры по количеству потоков **команд (Instruction Stream)** и **данных (Data Stream)**:
    1.  **SISD (Single Instruction, Single Data)** — Один поток команд, один поток данных. Классический фон-неймановский процессор.
    2.  **SIMD (Single Instruction, Multiple Data)** — Один поток команд, множество потоков данных. Одна команда применяется к множеству данных одновременно (векторные, матричные процессоры, расширения MMX/SSE/AVX).
    3.  **MISD (Multiple Instruction, Single Data)** — Множество потоков команд, один поток данных. Гипотетический класс, на практике почти не встречается (иногда к нему относят конвейерную обработку).
    4.  **MIMD (Multiple Instruction, Multiple Data)** — Множество потоков команд, множество потоков данных. Многопроцессорные и многоядерные системы.

---

### 39. Архитектура ОКОД (SISD)
**Один поток Команд, Один поток Данных (SISD)**.
*   **Описание**: Классическая последовательная архитектура фон Неймана. Один процессор (ядро) выполняет одну команду за такт над одной парой операндов.
*   **Способы повышения производительности**:
    *   **Конвейеризация (pipelining)** — разделение выполнения команды на этапы.
    *   **Суперскалярность** — несколько конвейеров для параллельного выполнения нескольких независимых команд.
*   **Пример**: Подавляющее большинство простых процессоров, одноядерные CPU.

---

### 40. Архитектура ОКМД: Векторные вычислительные системы (SIMD)
**Один поток Команд, Множество потоков Данных (SIMD)**.
*   **Векторные ВС**: Имеют специальные **векторные регистры** (длинные, 128-512 бит) и **векторные инструкции**. Одна команда (например, сложение) применяется ко всем элементам вектора одновременно.
*   **Примеры**:
    *   Исторические: Cray-1.
    *   Современные: Расширения команд CPU — **Intel MMX/SSE/AVX, ARM NEON/SVE**. **GPU** изначально построены по SIMD-принципу (выполняют одну программу-шейдер на множестве пикселей/вершин).

---

### 41. Архитектура ОКМД: Матричные вычислительные системы (SIMD)
**Разновидность SIMD**, где обрабатывающие элементы (ПЭ) организованы в **двумерную матрицу (решетку)**.
*   **Описание**: Каждый ПЭ имеет собственную локальную память и соединен с соседями. Один управляющий процессор рассылает команды всем ПЭ одновременно. Данные распределены по ПЭ.
*   **Применение**: Задачи с регулярной структурой данных (обработка изображений, решение сеточных уравнений).
*   **Пример**: ILLIAC IV (исторический), некоторые специализированные акселераторы.

---

### 42. Архитектура ОКМД: Ассоциативные вычислительные системы (SIMD)
**Разновидность SIMD с ассоциативной (контентно-адресуемой) памятью**.
*   **Описание**: Поиск данных в памяти осуществляется не по адресу, а **по содержимому (маске)**. Все ячейки памяти, удовлетворяющие маске, могут обрабатываться одновременно. ПЭ встроены в саму память.
*   **Применение**: Задачи поиска, базы данных, искусственный интеллект.
*   **Пример**: В чистом виде — экспериментальные системы. Принципы используются в кэш-памяти (TLB) и сетевом оборудовании (CAM-таблицы).

---

### 43. Архитектура ОКМД: Систолические вычислительные системы (SIMD)
**Разновидность SIMD, специализированная на потоковой обработке**.
*   **Описание**: Матрица однотипных ПЭ, синхронно работающих под тактовые сигналы ("пульсации", как систолы сердца). Данные ритмично "проталкиваются" от ПЭ к ПЭ, на каждом шаге подвергаясь обработке.
*   **Применение**: Цифровая обработка сигналов (фильтры, свертки), умножение матриц.
*   **Пример**: Специализированные СБИС для обработки видео/аудио.

---

### 44. Архитектура МКОД (MISD)
**Множество потоков Команд, Один поток Данных**.
*   **Описание**: Гипотетический класс. Несколько процессоров выполняют **разные команды** над **одними и теми же данными**.
*   **Интерпретации**:
    1.  **Конвейер (pipeline)**: Данные проходят через несколько стадий, каждая из которых выполняет свою операцию. Часто относят к этому классу, хотя это спорно.
    2.  **Избыточные системы для отказоустойчивости** (например, в авионике): несколько процессоров вычисляют одно и то же для сравнения результатов.
*   **Чистых примеров практически нет**.

---

### 45. Архитектура МКМД: понятие и классификация
**Множество потоков Команд, Множество потоков Данных (MIMD)**.
*   **Описание**: Наиболее общий и распространенный класс параллельных систем. Состоит из **нескольких независимых процессоров (ядер)**, каждый из которых выполняет свою собственную программу (поток команд) над своими собственными данными.
*   **Классификация по организации памяти**:
    1.  **Системы с общей памятью (Shared Memory)**: Все процессоры имеют единое адресное пространство и обращаются к общей памяти.
        *   **UMA (Uniform Memory Access)** — время доступа ко всей памяти одинаково (симметричные мультипроцессоры, SMP).
        *   **NUMA (Non-Uniform Memory Access)** — время доступа зависит от расположения памяти (локальная память быстрее, чем память на другом процессоре).
    2.  **Системы с распределенной памятью (Distributed Memory)**: Каждый процессор имеет свою локальную память. Обмен данными происходит путем передачи сообщений (MPI). Пример: кластеры, MPP-системы.

---

### 46. Архитектура МКМД: симметричные системы (SMP)
**Симметричные мультипроцессорные системы (Symmetric Multi-Processing, SMP)**.
*   **Описание**: Класс **UMA-систем**. Несколько идентичных процессоров (ядер) соединены через **общую системную шину или коммутатор** с общей памятью и устройствами ввода-вывода.
*   **Ключевые признаки**:
    *   **Единая операционная система** управляет всеми процессорами.
    *   **Единое адресное пространство** для всех процессов.
    *   **Равный доступ (UMA)**: Для любого процессора доступ к любой ячейке памяти или устройству ввода-вывода осуществляется одинаково быстро.
    *   **Связь через общую память**.
*   **Достоинства**: Простота программирования.
*   **Недостатки**: Проблема масштабируемости из-за конфликтов на общей шине.
*   **Пример**: Многоядерные процессоры для настольных ПК и серверов начального уровня (2-8 ядер).

---

### 47. Архитектура МКМД: параллельные векторные системы (PVP)
**Параллельные векторные системы (Parallel Vector Processor, PVP)**.
*   **Описание**: Гибридная архитектура **MIMD+SIMD**. Состоит из небольшого числа (8-16) мощных векторных процессоров (каждый является SIMD-машиной), соединенных высокой скоростной сетью и имеющих доступ к общей памяти.
*   **Характеристики**:
    *   Каждый процессор — высокопроизводительный векторный конвейер.
    *   Общая память с высокой пропускной способностью.
    *   Дорогие и специализированные системы для научных расчетов.
*   **Пример**: Исторические суперкомпьютеры Cray T90, NEC SX-9.

---

### 48. Архитектура МКМД: системы с неоднородным доступом к памяти (NUMA)
**NUMA (Non-Uniform Memory Access)**.
*   **Описание**: Архитектура MIMD с общей памятью, но **время доступа к памяти не одинаково**. Память физически распределена между процессорными узлами. Доступ к **локальной памяти** (на своем узле) быстрее, чем к **удаленной памяти** (на другом узле).
*   **Организация**: Каждый узел содержит один или несколько процессоров, локальную память и высокоскоростной контроллер (часто на базе HyperTransport или QuickPath Interconnect), соединяющий узлы.
*   **Достоинства**: Лучшая масштабируемость, чем у SMP.
*   **Недостатки**: Сложность программирования (необходимость учитывать локализацию данных).
*   **Пример**: Серверные платформы AMD Opteron (HyperTransport), Intel Xeon (QPI), современные многосокетные серверы.

---

### 49. Архитектура МКМД: системы с массовой параллельной обработкой (MPP)
**MPP (Massively Parallel Processing)**.
*   **Описание**: Класс систем с **распределенной памятью**. Состоит из большого числа (сотни, тысячи) вычислительных **узлов**. Каждый узел — это практически самостоятельный компьютер (процессор + своя локальная память + ОС). Узлы соединены высокоскоростной **коммуникационной сетью** (Infiniband, proprietary).
*   **Ключевые признаки**:
    *   **Нет общей физической памяти**. Обмен — только через передачу сообщений (MPI).
    *   Высокая масштабируемость до тысяч процессоров.
    *   Могут строиться из стандартных компонентов.
*   **Пример**: Классические суперкомпьютеры (IBM Blue Gene, Cray XT), крупные кластеры.

---

### 50. Архитектура МКМД: кластеры вычислительных машин
**Кластер (Cluster)** — частный случай **MPP-системы**, построенной из **серийно выпускаемых, стандартных компонентов** (обычно это обычные серверы или рабочие станции).
*   **Состав**:
    *   **Вычислительные узлы** (ноды).
    *   **Высокоскоростная сеть** (Ethernet, Infiniband, Myrinet).
    *   **Служебная сеть** (для управления).
    *   **Общие системы хранения** (SAN, NAS).
    *   **Программное обеспечение**: ОС, Middleware (например, MPI), ПО управления (PBS, Slurm).
*   **Типы**:
    *   **Кластеры высокой доступности (HA)** — для обеспечения бесперебойной работы.
    *   **Вычислительные кластеры (HPC Cluster)** — для решения научных задач.
    *   **Балансировщики нагрузки (Load Balancing)** — для веб-сервисов.
*   **Главное достоинство**: Отличное соотношение цена/производительность и масштабируемость.

---

### 51. Архитектура МКМД: кластеры больших SMP-систем
**Гибридная (иерархическая) архитектура**.
*   **Описание**: Каждый **узел кластера** сам по себе является не одно- или двухпроцессорной машиной, а **многопроцессорной SMP-системой** (например, 4-сокетный сервер с 64 ядрами).
*   **Структура**:
    *   **Уровень 1 (внутриузловой, SMP/UMA/NUMA)**: Многоядерные процессоры в одном корпусе с общей памятью. Параллелизм через потоки (OpenMP).
    *   **Уровень 2 (межузловой, MPP/Кластер)**: Множество таких SMP-узлов, соединенных высокоскоростной сетью. Параллелизм через передачу сообщений (MPI).
*   **Преимущества**: Объединяет сильные стороны обеих моделей: простота программирования на уровне узла (общая память) и высокая масштабируемость на уровне кластера.
*   **Пример**: Большинство современных суперкомпьютеров из списка Top500 (например, на базе узлов с процессорами Intel Xeon или AMD EPYC, соединенных Infiniband).
